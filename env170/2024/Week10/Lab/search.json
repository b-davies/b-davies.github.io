[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Week 8: Watch This Space",
    "section": "",
    "text": "Introduction\nEnvironmental data is often spatial in nature. Think about air quality as an environmental health topic. The effects of air quality on health in a city are determined in part by the topography and wind patterns of the local area, locations where emissions occur, and civic planning of neighborhoods, all of which combine to determine which groups are exposed to more or less polluted air. The geographic context is fundamental for understanding the variability of environmental phenomenon and developing solutions to environmental problems.\nSpatial data typically comes in two main flavors: vector and raster. The vector data model is commonly used to represent discrete features: things that exist in some places but not others. Think about the locations of fountains, or roads, or the footprints of buildings: these are all discrete features of a city. Rasters, on the other and, are gridded cells that represent continuous data: think about the distribution of temperatures or levels of particulate matter across a city.\n\n\n\n\n\n\n\nsaylordotorg.github.io\n\n\nVector data usually presents spatial objects as one of three kinds of features:\n\npoints (a location only)\nlines (a series connected points; location AND length)\npolygons (a series of connected points that form a closed loop; location AND area)\n\nAdditionally, these features can have attributes which are information associated with the spatial object. For example, a polygon representing a building might have attributes such as address, owner’s name, date of construction, current value, etc. For our purposes, attributes are synonymous with variables.\nIn this lab, we’re going to look at how to handle vector data in R. This allows us to integrate spatial data into our analyses without having to jump between software platforms, and share code and data in a way that is free and fully reproducible. Our main tool for doing this will be the sf package:\n\nlibrary(tidyverse)\nlibrary(sf)\n\nThe sf package uses the Simple Features object format, where spatial information are stored as tables with a special “geometry” column. This makes them more flexible for use by other packages. You can read more about Simple Features here, and about the history of spatial data handling in R here.\nThe data for today’s lab is on Canvas in the Week10LabData.zip file.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01_workingWithVector.html",
    "href": "01_workingWithVector.html",
    "title": "1  A First Look at Vector Data in R",
    "section": "",
    "text": "The sf package offers a lot of different functionality for handling vector data, and interfaces with many different packages that extend our analytical and visualization capabilities. But before we get into these aspects, it’s probably useful to see how the Simple Features geometry works with some of the things we already know. In this section, we’ll work through importing data, making changes to it using some of the tidyverse functions, and visualizing it using ggplot2.\n\nReading vector data from shapefiles\nBy and large, the ESRI shapefile is the standard for storing and sharing vector data. Shapefiles are actually collections of multiple files that store different aspects of the data (e.g., the .prj file contains projection information), but the main file in this structure is the .shp file. To read this kind of file, we’ll use the st_read function:\n\nsaCores&lt;-st_read(\"data/SACharCores.shp\")\n\nReading layer `SACharCores' from data source \n  `C:\\Users\\bdav_\\Dropbox\\Teaching\\ENV 170\\Fall 2024\\Lectures\\Week 10\\Lab\\data\\SACharCores.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 27 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 18.11663 ymin: -34.66926 xmax: 32.3673 ymax: -22.85796\nGeodetic CRS:  WGS 84\n\n\nThese data are locations of sediment cores containing microcharcoal that have been collected from sites around South Africa used to reconstruct fire history. The message above gives us some summary information about the dataset:\n\nThe file location where the data is being read in from and its file format (ESRI Shapefile)\nIt is being stored as a Simple Features collection with 27 features (the number of sediment cores) and 3 fields (variables)\nThe data has a POINT type geometry, meaning that it is a 0-dimensional geometry (e.g., it has no length, width, etc.)\nSomewhat confusingly, it then gives a value called “Dimension”, but this refers to the number of dimensions in the coordinate space (here it is XY data) rather than the dimensionality of the objects\nBounding box: This is the spatial extent covered by the data, represented by minimum and maximum x and y values\nThe coordinate reference system (or CRS) refers to the system that is being used to In this case, it is longitude/latitudes based on the WGS 84 datum\n\nWe can access these attributes individually using built-in functions of the sf package, which usually begin with the prefix st_ (which stands for spatial type). For example, to get the coordinates of the bounding box edges, we can use st_bbox:\n\n#Get the bounding box values\nst_bbox(saCores)\n\n     xmin      ymin      xmax      ymax \n 18.11663 -34.66925  32.36730 -22.85796 \n\n\nThis shows minimum and maximum x and y coordinates (here expressed in longitude and latitude) for the entire dataset. Likewise, if we wanted to access the coordinate reference system, we can use st_crs:\n\n#Get the bounding box values\nst_crs(saCores)\n\nCoordinate Reference System:\n  User input: WGS 84 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"latitude\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"longitude\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    ID[\"EPSG\",4326]]\n\n\nThis convoluted-looking set of metadata is a Well Known Text (WKT) formatting of coordinate reference information, developed by the Open Geospatial Consortium. It tells R what kind of space the coordinates exist in (e.g., planar vs spheroid).\nIf we just enter the spatial object’s name by itself, we get a summary of information about the dataset similar to the one above, but, like looking at a tibble, we also get a preview of the data itself:\n\nsaCores\n\nSimple feature collection with 27 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 18.11663 ymin: -34.66926 xmax: 32.3673 ymax: -22.85796\nGeodetic CRS:  WGS 84\nFirst 10 features:\n   SiteNo                SiteName SiteCode                  geometry\n1     280             Craigrossie      CRA      POINT (28.46 -28.54)\n2     322            Rietvlei Dam       RD      POINT (28.27 -25.88)\n3     335               Lake Teza      TEZ  POINT (32.3007 -28.5117)\n4     378                    Elim      ELI      POINT (28.41 -28.48)\n5     455 Wonderkrater borehole 3      WON      POINT (28.75 -24.43)\n6     598             Lake Sibaya      SIB  POINT (32.3673 -27.2065)\n7     600                 Funduzi      FUN     POINT (30.3 -22.8583)\n8     771               Braamhoek      BRA POINT (29.58333 -28.2333)\n9     774         Moreletta River      MOR       POINT (28.3 -25.73)\n10   1476          Tswaing Crater       TC POINT (28.0832 -25.40865)\n\n\nThese are the variables associated with our data (sometimes called attributes in GIS lingo). This is just a table of data with an extra column, geometry, that stores the spatial information. In fact, if we wanted to remove the spatial information and just use the associated data, the package offers a handy st_drop_geometry function, which will just leave you with a tibble of the variables:\n\ncoreSites&lt;-st_drop_geometry(saCores)\ncoreSites\n\n   SiteNo                SiteName SiteCode\n1     280             Craigrossie      CRA\n2     322            Rietvlei Dam       RD\n3     335               Lake Teza      TEZ\n4     378                    Elim      ELI\n5     455 Wonderkrater borehole 3      WON\n6     598             Lake Sibaya      SIB\n7     600                 Funduzi      FUN\n8     771               Braamhoek      BRA\n9     774         Moreletta River      MOR\n10   1476          Tswaing Crater       TC\n11   1479  Scot's Farm Borehole 1      SFB\n12   1480              Tate Vondo       TV\n13   1481                 Mahwaqa      MHQ\n14    775     Cederberg Pakhuisch      PAK\n15   1458            Verlorenvlei      VER\n16   1459            Pearly Beach       PB\n17   1460        Rietvlei Wetland       RW\n18   1461         Eilandvlei lake      EIL\n19   1462                De Rif-1      DR*\n20   1463                De Rif-2     &lt;NA&gt;\n21   1472           Princess Vlei      PRI\n22   1473         Katbakkies Pass      KBP\n23   1474              Groenkloof      GKF\n24   1475               Platbos 1      PB1\n25   1477              Pella 1_4a     &lt;NA&gt;\n26   1478          Vankervelsvlei      VAN\n27   1482               Pella 1_1     PEL*\n\n\n\n\nFields = Variables = Columns\nPrevious packages used for spatial work in R stored the data in complex ways, where each kind of data structure had its own object type, and accessing the variables might The sf package simplifies this process by treating all spatial information as a single variable, geometry, in an otherwise normal table of data.\nLet’s look at another shapefile: biomes of southern Africa. This comes from the South Africa National Biodiversity Institute and is based on a 2006 classification scheme by Mucina and Rutherford.\n\nsaBiomes&lt;-st_read(\"data/SABiomes.shp\",quiet=TRUE)\nsaBiomes\n\nSimple feature collection with 287 features and 7 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 16.45696 ymin: -34.8334 xmax: 32.89179 ymax: -22.12917\nGeodetic CRS:  WGS 84\nFirst 10 features:\n   BIOMEID           BIOME BIOMENAME POLYSQKM BIOMECODE POLYGONID BIOMESQKM\n1        8         Forests   Forests   31.367        FO         1   1062.17\n2        8         Forests   Forests   74.086        FO         2   1062.17\n3        6 Grassland Biome Grassland  606.697         G         3 360148.95\n4        8         Forests   Forests   20.073        FO         4   1062.17\n5        6 Grassland Biome Grassland   97.729         G         5 360148.95\n6        6 Grassland Biome Grassland   55.420         G         6 360148.95\n7        6 Grassland Biome Grassland   96.993         G         7 360148.95\n8        6 Grassland Biome Grassland   35.279         G         8 360148.95\n9        6 Grassland Biome Grassland   21.633         G         9 360148.95\n10       6 Grassland Biome Grassland   27.021         G        10 360148.95\n                         geometry\n1  MULTIPOLYGON (((31.17252 -2...\n2  MULTIPOLYGON (((30.01046 -2...\n3  MULTIPOLYGON (((30.0337 -23...\n4  MULTIPOLYGON (((30.02757 -2...\n5  MULTIPOLYGON (((29.1999 -24...\n6  MULTIPOLYGON (((28.84413 -2...\n7  MULTIPOLYGON (((29.71844 -2...\n8  MULTIPOLYGON (((29.0852 -24...\n9  MULTIPOLYGON (((28.59739 -2...\n10 MULTIPOLYGON (((28.5839 -24...\n\n\nHere you can see a similar summary to the previous dataset, but a major distinction is that this is MULTIPOLYGON data, or 2-dimensional geometry (e.g., has length and width). The sf package distinguishes between POLYGON and MULTIPOLYGON data. In a POLYGON geometry, each individual polygon is a distinct feature, while in a MULTIPOLYGON geometry, multiple polygons might be included in a single feature.\nYou could think about it in terms of the main islands of Hawaii:\n\n\n\n\n\nA POLYGON dataset might have separate features for Oahu, Maui, Kauai, and so on, while a MULTIPOLYGON dataset might have 8 polygons that are all a single object called “Hawaii”. For the biomes dataset, some biomes may include several disconnected components, but are here considered to be a single “multipolygon”.\nBecause the data are stored as a table, we can use pretty much any of the functions we would normally use to access and manipulate the data. Here, we’ll modify the data using filter and select to include only a subset of rows and columns:\n\nsavanna&lt;-saBiomes |&gt;\n  filter(BIOMENAME==\"Savanna\") |&gt;\n  select(BIOME,POLYSQKM,BIOMESQKM)\n  \nsavanna\n\nSimple feature collection with 58 features and 3 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 19.99944 ymin: -33.56281 xmax: 32.61765 ymax: -22.12917\nGeodetic CRS:  WGS 84\nFirst 10 features:\n           BIOME POLYSQKM BIOMESQKM                       geometry\n1  Savanna Biome   29.175  418564.4 MULTIPOLYGON (((28.57282 -2...\n2  Savanna Biome   91.943  418564.4 MULTIPOLYGON (((27.74764 -2...\n3  Savanna Biome   22.009  418564.4 MULTIPOLYGON (((28.11957 -2...\n4  Savanna Biome   82.667  418564.4 MULTIPOLYGON (((28.11963 -2...\n5  Savanna Biome  703.326  418564.4 MULTIPOLYGON (((27.89195 -2...\n6  Savanna Biome  191.453  418564.4 MULTIPOLYGON (((28.38203 -2...\n7  Savanna Biome  187.384  418564.4 MULTIPOLYGON (((28.64878 -2...\n8  Savanna Biome  209.071  418564.4 MULTIPOLYGON (((26.68986 -2...\n9  Savanna Biome  146.613  418564.4 MULTIPOLYGON (((28.5071 -26...\n10 Savanna Biome   22.608  418564.4 MULTIPOLYGON (((27.48282 -2...\n\n\nAnd because the data are in table format, we can also integrate them into a ggplot function to quickly view patterns within the data. For example, let’s say we wanted to assess the total square kilometers in the Fynbos and Savanna biomes:\n\nbiomeCompare&lt;-filter(saBiomes,BIOMENAME %in% c(\"Fynbos\",\"Savanna\"))\nggplot(biomeCompare,aes(x=BIOMENAME,y=POLYSQKM)) +\n  geom_col()\n\n\n\n\n\n\n\n\n\n\nVisualizing spatial data with geom_sf\nOver the years, the developers of ggplot2 have recognized widespread interest in using the package to make maps, and have updated the software to include handling and plotting of spatial data At the same time, efforts like the promotion of the Simple Features data structure are a recognition that data interoperability is a priority for many data users.\nThese two processes meet in the middle with the geom_sf object. This is a way of translating Simple Features data (like that from the sf package) into a format that can be manipulated in the ggplot2 environment. For example\n\nggplot(data= saCores) + \n  geom_sf()\n\n\n\n\n\n\n\n\nThis probably looks very similar to what you might expect from geom_point, and this makes sense since we’re dealing with point data. However, geom_sf is designed to handle vector data in a range of formats. For example, we can use the same function call to plot our polygon biomes data:\n\nggplot(data= saBiomes) + \n  geom_sf() \n\n\n\n\n\n\n\n\nWhat’s important to keep in mind here is that geom_sf is taking into account the information in the geometry column of the object. It recognizes that this is polygon data, so it plots it accordingly.\nNow that the data are in a ggplot function, we can add some aesthetic mappings. For starters, let’s map the biomes on to the color variable:\n\nggplot(data= saBiomes,aes(fill=BIOME)) + \n  geom_sf() \n\n\n\n\n\n\n\n\nThat looks pretty good, but there are some things that aren’t really working for this map. For example, the grey background is pretty unnecessary in this case, so we can get rid of it using a theme like theme_classic or theme_minimal.\nWe also probably don’t need the dark grey borders around each polygon; in places where there’s a lot of lines close together it gets pretty messy. We can eliminate these by adding color=NA to the geom_sf function. This is saying to not plot the elements to which color would be mapped. Since it’s being applied over the whole plot, and not relative to some variable in the data, we don’t need the aes function.\nFinally, we can also add a label to the legend to edit the capitalization on the variable name.\n\nggplot(data= saBiomes,aes(fill=BIOME)) + \n  geom_sf(color=NA) +\n  theme_classic() +\n  labs(fill=\"Biome\")\n\n\n\n\n\n\n\n\nMuch better. Keep in mind right now we’re mapping a nominal (categorical) value to fill, but we could just as easily use a ratio/interval (continuous) value. For example, instead of using the name of the biome, we could color by the total area in square kilometers:\n\nggplot(data= saBiomes,aes(fill=BIOMESQKM)) + \n  geom_sf(color=NA) +\n  theme_classic() +\n  labs(fill=bquote(\"Biome Area\"~(km^2)))\n\n\n\n\n\n\n\n\nNotice the use of the bquote function to modify the label to include the superscripted 2, which we learned about last week.\nOK, back to our biomes map. The color scheme is a bit intense: when working with mapped data that covers large areas of graphic, it’s usually a good idea to use more muted tones. To do this, we’re going to draw on our friend ColorBrewer with the scale_fill_brewer function:\n\nggplot(data= saBiomes,aes(fill=BIOME)) + \n  geom_sf(color=NA) +\n  theme_classic() +\n  labs(fill=\"Biome\") +\n  scale_fill_brewer(palette=\"Set3\")\n\n\n\n\n\n\n\n\nNow let’s say we want to add the cores as a layer to this map. We can do this by adding another geom_sf call, but this time using the cores object as the data argument:\n\nggplot(data= saBiomes,aes(fill=BIOME)) + \n  geom_sf(color=NA) +\n  theme_classic() +\n  labs(fill=\"Biome\") +\n  scale_fill_brewer(palette=\"Set3\") +\n  geom_sf(data=saCores)\n\nError in `geom_sf()`:\n! Problem while computing aesthetics.\nℹ Error occurred in the 2nd layer.\nCaused by error:\n! object 'BIOME' not found\n\n\nOops. What happened? This error relates to the way we’re doing the aesthetic mapping. At the moment, the aes function is inside the opening ggplot function, so this mapping is being applied to every geom underneath it. But since we now have geoms coming from two different datasets (biomes and cores), the mapping won’t make sense because the cores data has different variables.\nWhen you’re dealing with more than one dataset, it’s good practice to put the arguments in the geoms they are referencing. So here, we’ll move the arguments from the ggplot function into the first geom_sf function:\n\nggplot() + \n  geom_sf(data= saBiomes,aes(fill=BIOME),color=NA) +\n  theme_classic() +\n  labs(fill=\"Biome\") +\n  scale_fill_brewer(palette=\"Set3\") +\n  geom_sf(data=saCores)\n\n\n\n\n\n\n\n\nLovely. Keep in mind that the order in which you place the geoms will determine their drawing order of each layer. So, for example, if we moved the geom_sf that plots the cores up to the top of the function, our cores will be hidden behind the biomes data that gets plotted immediately afterwards:\n\nggplot() + \n  geom_sf(data=saCores) +\n  geom_sf(data= saBiomes,aes(fill=BIOME),color=NA) +\n  theme_classic() +\n  labs(fill=\"Biome\") +\n  scale_fill_brewer(palette=\"Set3\")\n\n\n\n\n\n\n\n\nWe can keep modifying this image until we’re happy with how it looks, just as we have with other kinds of plots. But just by adding a few new function to our toolkit, like st_read and geom_sf, we’re able to incorporate spatial data into our work.\n\n\n\n\n\n\nTry it yourself!\n\n\n\nThere’s an additional shapefile in here called south_africa_border, which gives the borders of South Africa, Lesotho, and Eswatini. Using what you’ve learned above, read this file in, plot it and then add it the plot with the biomes and the cores.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>A First Look at Vector Data in R</span>"
    ]
  },
  {
    "objectID": "02_handingVectorData.html",
    "href": "02_handingVectorData.html",
    "title": "2  Vector Data Handling",
    "section": "",
    "text": "Making spatial data from scratch\nBecause sf objects are effectively tables, the process of making our own spatial data is pretty straightforward. Here, we’ll create three vectors. The first two will hold some x and y coordinates, while the last will be some made-up yes/no data. We’ll then combine these into a tibble called xydata:\n\nx&lt;-c(28,23,19)\ny&lt;-c(-26,-30,-33)\ndata&lt;-c(\"yes\",\"yes\",\"no\")\nxydata&lt;-tibble(x,y,data)\nxydata\n\n# A tibble: 3 × 3\n      x     y data \n  &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;\n1    28   -26 yes  \n2    23   -30 yes  \n3    19   -33 no   \n\n\nKeep in mind here that the negative numbers, which are on the y (latitude) axis, mean they are south of the equator. Most of the information we need to convert this into spatial data is here. We can use the st_as_sf function to go from a table to an sf object:\n\npointData&lt;-st_as_sf(xydata,coords=c(\"x\",\"y\"))\npointData\n\nSimple feature collection with 3 features and 1 field\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 19 ymin: -33 xmax: 28 ymax: -26\nCRS:           NA\n# A tibble: 3 × 2\n  data  geometry\n  &lt;chr&gt;  &lt;POINT&gt;\n1 yes   (28 -26)\n2 yes   (23 -30)\n3 no    (19 -33)\n\n\nThe two arguments to st_as_sf here are the name of the table, and then the coords argument, which tells the function which columns the geometry data are stored in (in this case, the X and Y columns).\nThe result looks a little different from what we’ve seen before, where the summary is presented as separate from the data table. The reason is that st_as_sf was principally designed to convert other spatial data formats that are built around Base R and the dataframe structure, making the package better at dealing with legacy code. However, this won’t make much difference in our ability to use the data:\n\nggplot() +\n  geom_sf(data=pointData)\n\n\n\n\n\n\n\n\nThe bigger issue here is that our data don’t yet have a coordinate reference system. The CRS tells R what kind of space our coordinates are in (e.g., planar vs. geodetic). To add one, we can use the st_crs function around our new dataset, and then assign a value:\n\nst_crs(pointData)&lt;-4326\n\nBy assigning a number to this, we are now giving the object a CRS. But why did we assign 4326? This number is an ESPG code, developed by the European Petroleum Survey Group for the registration of geodetic datums. This specific number refers to the WGS84 datum, which is the standard used for global positioning systems.\nPerhaps not so coincidentally, our South African data from the last section also use the same CRS:\n\nsaBorder&lt;-st_read(\"data/south_africa_border.shp\",quiet=TRUE)\nst_crs(saBorder)\n\nCoordinate Reference System:\n  User input: WGS 84 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"latitude\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"longitude\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    ID[\"EPSG\",4326]]\n\n\nThis means that we can plot these two together without any distortion, like so:\n\nggplot() +\n  geom_sf(data=saBorder) +\n  geom_sf(data=pointData)\n\n\n\n\n\n\n\n\nKeep in mind that you can do this with just about any data table in R that has coordinates. For example, looking at our Sacramento data:\n\nlibrary(modeldata)\nsacSpat&lt;-st_as_sf(Sacramento,coords=c(\"longitude\",\"latitude\"))\nggplot()+\n  geom_sf(data=sacSpat, aes(color=type))\n\n\n\n\n\n\n\n\nOf course, for this map to work it would be helpful to see it on a map of Sacramento. We’ll look at ways to do this in a moment.\n\n\nVector data operations\nVector data can be used to answer questions related to spatial relationships between different things. We can access these using methods that operate on the data tables, using techniques we’ve learned in data wrangling, as well as the spatial data itself.\nFor example, let’s say that a study showed that the top threat to a species of moths on the Cape Cod islands was vehicle interactions. A commission on Martha’s Vineyard wants us to assess where moths are most threatened on the island. So we’re interested in looking at the relationship between the moth’s preferred habitat, and where that might overlap with traffic.\nFirst, we’ll load in data of the islands coastlines:\n\ncoasts&lt;-st_read(\"data/island_outline.shp\",quiet=TRUE)\ncoasts\n\nSimple feature collection with 18 features and 3 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 255304.2 ymin: 777606.4 xmax: 329063.4 ymax: 804036.7\nProjected CRS: NAD83 / Massachusetts Mainland\nFirst 10 features:\n   OBJECTID Shape_Leng   Shape_Area                       geometry\n1         1  7014.7797 2352697.2299 POLYGON ((257734.8 779309.7...\n2         2 12001.3137 4559235.3924 POLYGON ((303023.4 785266.6...\n3         3   814.9956   27325.2581 POLYGON ((261860.9 786724.1...\n4         4   103.6876     443.1637 POLYGON ((300811 787461.1, ...\n5         5   220.8608    1700.1933 POLYGON ((299321.3 787528.6...\n6         6  1093.8214   42126.6728 POLYGON ((301238.1 787594.1...\n7         7  5405.8272 1173785.7943 POLYGON ((300537.6 788262.9...\n8         8   800.8689   26351.6747 POLYGON ((261301.3 788321.3...\n9         9   161.8800     918.3625 POLYGON ((300787.1 789076.4...\n10       10   313.2050    4361.2121 POLYGON ((301065.9 789324.7...\n\n\nThis dataset has 18 objects (in this case, polygons representing the coastlines of islands), and 3 fields/variables: OBJECTID (an ID number), Shape_Leng (the length of each polygon in m), and Shape_Area (the area of each polygon in m2) . Let’s plot it and have a look:\n\nggplot() +\n  geom_sf(data=coasts)\n\n\n\n\n\n\n\n\nMartha’s Vineyard is the larger island to the west. We don’t need to look at Nantucket or other smaller islands here, so we want to subset to just Martha’s Vineyard. Because the data are stored as a table, we can use our tidyverse tools here to help us. In this case, we can use slice_max from dplyr to get the largest island in dataset.\n\nmv&lt;-slice_max(coasts,Shape_Area)\nggplot() +\n  geom_sf(data=mv)\n\n\n\n\n\n\n\n\nRemembering back to Week 7, the slice_max function selects the row that has the highest value in a given column. Since we gave it the Shape_Area column, the row with the highest value is Martha’s Vineyard.\nNext, we’ll load in some data on the roads. But our road data covers both Martha’s Vineyard and Nantucket.\n\nroads&lt;-st_read(\"data/island_roads.shp\",quiet=TRUE)\nggplot() +\n  geom_sf(data=roads)\n\n\n\n\n\n\n\n\nIn this case, we want to subset to only those roads on Martha’s Vineyard. We can do this by using the st_intersection function with the mv object we created above:\n\nmvRoads&lt;-st_intersection(roads,mv)\n\nWarning: attribute variables are assumed to be spatially constant throughout\nall geometries\n\nggplot()+\n  geom_sf(data=mvRoads)\n\n\n\n\n\n\n\n\nThis function takes two arguments at minimum: the first is the dataset of interest (roads), and the second is the dataset it is interacting with (mv). The result, as you can see, is any roads that intersects with our mv object.\nNow we need to know something about habitat distributions. We can use the island_landuse.shp file, but like our roads, we’ll need to subset it to Martha’s vineyard only.\n\nlanduse&lt;-st_read(\"data/island_landuse.shp\",quiet=TRUE)\nmvLanduse&lt;-st_intersection(landuse,mv)\n\nWarning: attribute variables are assumed to be spatially constant throughout\nall geometries\n\nggplot()+\n  geom_sf(data=mv) +\n  geom_sf(data=mvLanduse)\n\n\n\n\n\n\n\n\nThere’s a few different variables in this data, but the one that’s most likely to help us figure out habitats and threats is the LU05_DESC, which is a description of landuse on a parcel of land as observed in 2005. The moth lives in Open as well as Brushland/ Successional habitats. We can subset to just these with the filter function\n\npreferredHabitats&lt;-filter(mvLanduse,LU05_DESC %in% c(\"Open Land\", \"Brushland/Successional\"))\nggplot()+\n  geom_sf(data=mv) +\n  geom_sf(data=preferredHabitats,fill=\"darkgreen\")\n\n\n\n\n\n\n\n\nOK, now we have everything we need. Let’s say the study found that most damage to moth populations occurred within 50 meters of a road. We can evaluate this relationship by using a buffer. A buffer creates a polygon at some even distance around a feature. This is useful when you want to see or measure how many instances of one thing fall within some distance of another.\nThe function we want to use for this is st_buffer, which will take as arguments the name of the object being buffered (in this case, the mvRoads) and a distance (in the default units here, 50m):\n\nroadBuffer&lt;-st_buffer(mvRoads,50)\nggplot()+\n  geom_sf(data=roadBuffer)\n\n\n\n\n\n\n\n\nAs you can see (though maybe not clearly) from this image, the lines where the roads are have now been surrounded by a polygon, giving us the area around the roads that are most dangerous for moths. Now we can look at the threat relationship between these preferred habitats and roads using the st_intersection function:\n\nroadThreat&lt;-st_intersection(preferredHabitats,roadBuffer)\n\nWarning: attribute variables are assumed to be spatially constant throughout\nall geometries\n\nggplot()+\n  geom_sf(data=mv) +\n  geom_sf(data=mvRoads) +\n  geom_sf(data=roadThreat,fill=\"red\",color=NA)\n\n\n\n\n\n\n\n\nThis map shows us where the months are most , though perhaps it could do better at communicating these ideas. We can modify the look of figure to make sure the headline is clear:\n\nggplot()+\n  geom_sf(data=mv,fill=\"grey90\",color=NA) +\n  geom_sf(data=mvRoads,color=\"darkgrey\") +\n  geom_sf(data=roadThreat,fill=\"red\",color=NA) +\n  theme_void() +\n  labs(title=\"Where the moths of Martha's Vineyard are most threatened\", subtitle=\"Red indicates areas of high probability of road strike\")\n\n\n\n\n\n\n\n\n\n\nUsing joins to combine table and spatial data\nMore often than not, you may want to do some kind of analysis or visualization only to find you have one variable stored in one dataset, and another stored in another dataset. This can be a bit frustrating, but there are tools. The most helpful of these is the left_join function. This takes two datasets and uses a common shared variable to join them together. This can be particularly helpful when some\nThis can be particularly helpful when you have table data and want to map it. Let’s say we wanted to view our 2007 life expectancy data from the gapminder dataset as a map. First, we’ll subset bring in that data and subset it to just 2007 and just the country and lifeExp columns:\n\nlibrary(gapminder)\ngm2007&lt;-gapminder |&gt;\n  filter(year==2007) |&gt;\n  select(country,lifeExp)\ngm2007\n\n# A tibble: 142 × 2\n   country     lifeExp\n   &lt;fct&gt;         &lt;dbl&gt;\n 1 Afghanistan    43.8\n 2 Albania        76.4\n 3 Algeria        72.3\n 4 Angola         42.7\n 5 Argentina      75.3\n 6 Australia      81.2\n 7 Austria        79.8\n 8 Bahrain        75.6\n 9 Bangladesh     64.1\n10 Belgium        79.4\n# ℹ 132 more rows\n\n\nNext, we’ll bring in a shapefile of world country boundaries, obtained from the very helpful website Natural Earth:\n\nworldCountries&lt;-st_read(\"data/world.shp\",quiet=TRUE)\nggplot() +\n  geom_sf(data=worldCountries)\n\n\n\n\n\n\n\n\nThis dataset has a lot of variables, most of them relating to database management. For now, we’ll cut this down to just the columns with the country name and its subregion.\n\nworldCountries&lt;-worldCountries |&gt;\n  select(name,subregion)\nworldCountries\n\nSimple feature collection with 241 features and 2 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -180 ymin: -89.99893 xmax: 180 ymax: 83.59961\nGeodetic CRS:  +proj=longlat +datum=WGS84 +no_defs\nFirst 10 features:\n                   name       subregion                       geometry\n1                 Aruba       Caribbean MULTIPOLYGON (((-69.89912 1...\n2           Afghanistan   Southern Asia MULTIPOLYGON (((74.89131 37...\n3                Angola   Middle Africa MULTIPOLYGON (((14.19082 -5...\n4              Anguilla       Caribbean MULTIPOLYGON (((-63.00122 1...\n5               Albania Southern Europe MULTIPOLYGON (((20.06396 42...\n6                 Aland Northern Europe MULTIPOLYGON (((20.61133 60...\n7               Andorra Southern Europe MULTIPOLYGON (((1.706055 42...\n8  United Arab Emirates    Western Asia MULTIPOLYGON (((53.92783 24...\n9             Argentina   South America MULTIPOLYGON (((-64.54917 -...\n10              Armenia    Western Asia MULTIPOLYGON (((45.55234 40...\n\n\nOK, now we have our two datasets, with one column that contains the same value: the country name. In the gm2007 dataset, it’s in the country column, while in the worldCountries dataset, it’s stored as name.\nWe can use left_join from dplyr to put these two datasets together:\n\ngmJoin1&lt;-left_join(worldCountries,gm2007,by=c(\"name\"=\"country\"))\ngmJoin1\n\nSimple feature collection with 241 features and 3 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -180 ymin: -89.99893 xmax: 180 ymax: 83.59961\nGeodetic CRS:  +proj=longlat +datum=WGS84 +no_defs\nFirst 10 features:\n                   name       subregion lifeExp                       geometry\n1                 Aruba       Caribbean      NA MULTIPOLYGON (((-69.89912 1...\n2           Afghanistan   Southern Asia  43.828 MULTIPOLYGON (((74.89131 37...\n3                Angola   Middle Africa  42.731 MULTIPOLYGON (((14.19082 -5...\n4              Anguilla       Caribbean      NA MULTIPOLYGON (((-63.00122 1...\n5               Albania Southern Europe  76.423 MULTIPOLYGON (((20.06396 42...\n6                 Aland Northern Europe      NA MULTIPOLYGON (((20.61133 60...\n7               Andorra Southern Europe      NA MULTIPOLYGON (((1.706055 42...\n8  United Arab Emirates    Western Asia      NA MULTIPOLYGON (((53.92783 24...\n9             Argentina   South America  75.320 MULTIPOLYGON (((-64.54917 -...\n10              Armenia    Western Asia      NA MULTIPOLYGON (((45.55234 40...\n\n\nThe arguments here work as follows:\n\nWe give the function a dataset (here the worldCountries data). This is the data that we are joining to, so the output will look like worldCountries but with some additional variables from another dataset.\nThe gm2007 tibble is the second argument. The columns from this dataset will be attached to those from the worldCountries dataset.\nFinally, the by argument allows us to say which column from the first dataset (name) matches which column in the second dataset (country).\n\nOur new sf object now has the two columns from the original Natural Earth spatial data (name and subregion), as well as a new column for lifeExp that comes from the gm2007 data. Now we can plot our data and see what it looks like spatially.\n\nggplot() +\n  geom_sf(data=gmJoin1,aes(fill=lifeExp))\n\n\n\n\n\n\n\n\nThis let’s us see how the gapminder data looks on a familiar image: the world map. It’s also interesting to see where data isn’t available (notably, central Asia); this is less obvious when working with the table data.\nThis joining process will also work with two tables, or with two different sets of spatial data. As long as they can be linked by some common key value (here, the names of countries), you can combine them into a single dataset that can then be used for analysis and visualization.\n\n\n\n\n\n\nTry it yourself!\n\n\n\nThe left_join works by joining the first object (the leftmost one in the function call) to a second. What happens when you reverse the order of the input data? In other words can you join gm2007 tibble to the worldCountries sf object? Can you create boxplots of life expectancy based on subregion?\n\n\nThere are many additional ways you might want to manipulate spatial data in R. Unfortunately, going into them in detail is outside the scope of this course. For now, if you’re interested in learning more, the book Geocomputation with R gives an excellent survey of spatial data manipulation.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Vector Data Handling</span>"
    ]
  },
  {
    "objectID": "03_plottingVectorData.html",
    "href": "03_plottingVectorData.html",
    "title": "3  Additional plotting considerations",
    "section": "",
    "text": "Modifying extents and adding map elements\nLet’s rebuild our South Africa map of cores and biomes:\nggplot() + \n  geom_sf(data= saBiomes,aes(fill=BIOME),color=NA) +\n  theme_classic() +\n  labs(fill=\"Biome\") +\n  scale_fill_brewer(palette=\"Set3\") +\n  geom_sf(data=saCores)\nLet’s say that we were just interested in the area around Western Cape (in the southwest part of South Africa). In Week 4, we looked at how we can zoom in on a plot using coord_cartesian to set new limits to the extent being plotted. A similar function, coords_sf, let’s us do this with our spatial data:\nggplot() + \n  geom_sf(data= saBiomes,aes(fill=BIOME),color=NA) +\n  theme_classic() +\n  labs(fill=\"Biome\") +\n  scale_fill_brewer(palette=\"Set3\") +\n  geom_sf(data=saCores) +\n  coord_sf(xlim = c(17, 23), ylim = c(-35, -30), expand = FALSE)\nThis looks OK, but there’s a whole bunch of colors in the legend now that don’t correspond to anything on the map. The reason is that even though we’ve zoomed in, we haven’t actually subset the data, so this We can use st_crop to crop the data to our new bounding box.\nbiomesCrop&lt;-st_crop(saBiomes, xmin=17, xmax=23, ymin=-35, ymax=-30)\n\nWarning: attribute variables are assumed to be spatially constant throughout\nall geometries\n\ncoresCrop&lt;-st_crop(saCores, xmin=17, xmax=23, ymin=-35, ymax=-30)\n\nWarning: attribute variables are assumed to be spatially constant throughout\nall geometries\n\nggplot() + \n  geom_sf(data= biomesCrop,aes(fill=BIOME),color=NA) +\n  theme_classic() +\n  labs(fill=\"Biome\") +\n  scale_fill_brewer(palette=\"Set3\") +\n  geom_sf(data=coresCrop)\nThis takes the name of the sf object as the first argument, and then a series of values indicating the minimum and maximum extents along the x and y axes. The color scheme has changed now since we’re not using so many of them.\nLet’s add a couple more things to our plot: labels and a scale bar. The easiest way to do this is to call up the ggspatial package:\nlibrary(ggspatial)\n\nggplot() + \n  geom_sf(data= biomesCrop,aes(fill=BIOME),color=NA) +\n  theme_classic() +\n  labs(fill=\"Biome\") +\n  scale_fill_brewer(palette=\"Set3\") +\n  geom_sf(data=coresCrop) +\n   annotation_north_arrow()\nHere we used the annotation_north_arrow() function to get our arrow, but eek! It’s gigantic! We can play around with some settings, like height and width, to get it into a more reasonable shape:\nlibrary(ggspatial)\n\nggplot() + \n  geom_sf(data= biomesCrop,aes(fill=BIOME),color=NA) +\n  theme_classic() +\n  labs(fill=\"Biome\") +\n  scale_fill_brewer(palette=\"Set3\") +\n  geom_sf(data=coresCrop) +\n   annotation_north_arrow(height = unit(0.75, \"cm\"), width = unit(0.5, \"cm\"))\nThis looks better. Now for a scale bar using annotation_scale:\nggplot() + \n  geom_sf(data= biomesCrop,aes(fill=BIOME),color=NA) +\n  theme_classic() +\n  labs(fill=\"Biome\") +\n  scale_fill_brewer(palette=\"Set3\") +\n  geom_sf(data=coresCrop) +\n   annotation_north_arrow(height = unit(0.75, \"cm\"), width = unit(0.5, \"cm\")) +\n  annotation_scale(location = \"br\")\nThe location argument that is used here (\"br\") indicates that we want to put it in the bottom right corner. We could use \"tr\" for top right, or \"bl\" for bottom left. It’s entirely up to you!",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Additional plotting considerations</span>"
    ]
  },
  {
    "objectID": "03_plottingVectorData.html#modifying-extents-and-adding-map-elements",
    "href": "03_plottingVectorData.html#modifying-extents-and-adding-map-elements",
    "title": "3  Additional plotting considerations",
    "section": "",
    "text": "Try it yourself!\n\n\n\nThere are lots of different options for changing the look and feel of these map elements, such as the size, location, and style. Have a look at the help documentation for these two functions to get a better sense.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Additional plotting considerations</span>"
    ]
  },
  {
    "objectID": "LabExercise8.html",
    "href": "LabExercise8.html",
    "title": "4  Lab Exercise 10",
    "section": "",
    "text": "news.mongabay.com\n\n\nIn this exercise, you will use the skills from this lab and previous labs to visualize some spatial data and use it to address a research question:\nWhat is the most prominent primate family found in the Brazilian state of Mato Grosso?\nYou have two datasets in the data folder to use for this exercise:\n\nA shapefile, brazilStates.shp, that is polygon spatial data for the states of Brazil (source: Natural Earth)\nA CSV file, primateObservations.csv, that is table data of primate observations from the Global Biodiversity Information Facility (GBIF), covering all of South America.\n\nIn this assignment, you will generate two visualizations:\n\nthe frequency of different primate families observed in the state of Mato Grosso\nthe spatial distribution of primate observations in Brazil, with an emphasis on primate families in Mato Grosso\n\nFor both of these figures, the goal is to highlight the most prevalent species observed in Mato Grosso.\nSubmit your assignment as a Quarto document using the form on Canvas. Details about assessment are posted there.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lab Exercise 10</span>"
    ]
  }
]